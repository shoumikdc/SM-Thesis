\chapter{Introduction\label{ch:1_Introduction}}

\section{From Quantum Computation to Error Correction}

The field of quantum information science (QIS) involves leveraging the fundamental principles of quantum mechanics to accomplish novel and useful information processing tasks. Central to this vision is a machine called the quantum computer, which at its lowest level encodes information in the quantum mechanical degrees of freedom of a physical system. The promise of quantum computers is to solve certain computational problems more efficiently than conventional classical computers and this has, in large part, motivated the remarkable pace of development of QIS over the last two decades. 

The low-level building blocks of quantum computers are called quantum bits, or \textit{qubits}. A physical qubit can be realized using any two-level quantum system, and there are many proposed platforms for doing so: e.g. the spin of an electron \cite{burkard2023semiconductor}, or the lowest quantized energy levels of an atom \cite{briegel2000quantum} or superconducting circuit \cite{devoret2013superconducting, krantz2019quantum, kjaergaard2020superconducting}. The latter has emerged as a leading candidate for engineering quantum systems: superconducting qubits routinely achieve coherence times on the order of hundreds of microseconds \cite{kjaergaard2020superconducting} (thanks to dedicated improvements in materials, fabrication, and circuit design), and can now be scaled up to small-to-medium-sized quantum processors. Although several of the ideas presented in this thesis are quite general (e.g. notions of quantum error correction), we will focus on their specific implementation within superconducting circuits. 

The basis states of a qubit are typically labelled $\ket{0}$ and $\ket{1}$, analogous to a classical bit. In quantum computation, it is also possible to have arbitrary \textit{superposition} states, specified via a linear combination
\begin{equation}
    \ket{\psi} = \alpha\ket{0} + \beta\ket{1}.
\end{equation}
Here, the values of the coefficients $|\alpha|^2$ and $|\beta|^2$ give the probabilities of measuring the quantum system in state $\ket{0}$ or $\ket{1}$. More generally, an $N$-qubit system will have $2^N$ basis states, with the most general multi-qubit state written as a superposition of all of them. A quantum computation, then, involves manipulating the quantum state of a system using a series of gate operations in order to prepare a given final state that encodes the solution to the given computational problem. Using this model of computation, it is believed that quantum computers will offer an exponential run-time advantage over classical machines for certain difficult computational problems \cite{manenti2023quantum, ike-and-mike}. 

Unfortunately, quantum information is---more so than classical information---highly susceptible to noise and errors due to unwanted interactions between a qubit and its environment. The simplest example of this is a \textit{bit-flip} error $\ket{1} \leftrightarrow \ket{0}$, which occurs on a characteristic timescale $T_1$ due to excitation or relaxation processes in the physical qubit. More complicated errors can also arise due to the nature of quantum superposition, e.g. \textit{phase flips}: $\ket{0} + \ket{1} \leftrightarrow \ket{0} - \ket{1}$, which occur with characteristic timescale $T_\varphi$. The process by which qubit state errors of this kind arise is known as \textit{decoherence}, and it is among the most significant challenges towards scaling up quantum systems. It has long been known that in order to achieve fault-tolerance, future quantum machines will need to actively detect when errors occur and correct them in real time via a process called quantum error correction (QEC) \cite{shor1996fault}.

The central goal of QEC is to use a larger state space than just the two levels of a physical qubit to redundantly encode information in a manner that is robust to noise --- in a similar spirit to classical error correcting codes.
The remarkable feature of QEC is that performing quantum measurements and collapsing the physical state of the system in order to check for errors need not affect the logical information being stored. Typically, one uses a register of $N$ qubits, and stores information within a two-dimensional subspace of the $2^N$-dimensional multi-qubit state space \cite{shor1995scheme, steane1996error, gottesman1996class, kitaev2003fault, fowler2012surface}, with the most popular QEC code today being the so-called \textit{surface code} (which lays out the physical qubits on a 2D lattice and uses low-weight parity checks to detect and correct errors) \cite{fowler2012surface}. This approach is currently the ``north-star'' that our field is working towards, with many recent demonstrations showing promising QEC results using register-based codes \cite{google2023suppressing, bluvstein2024logical, campbell2024series}. One important feature of the surface code in particular is the existence of the so-called QEC threshold theorem \cite{aharonov1997fault,knill1998resilient}, which loosely speaking states that the logical error rate of the code $p_L$ scales exponentially as $p_L \sim (p_{\rm err}/p_{\rm thres})^{\mathcal{O}(d)}$, where $p_{\rm err}$ is the physical qubit error rate and $p_{\rm thres}$ is the threshold. Thus, if we can achieve error rates below the threshold $p_{\rm err} \ll p_{\rm thres}$, then the logical error probability can be suppressed exponentially by increasing the code distance $d$ (which is proportional to the number of physical qubits). The existence of the threshold provides us with a roadmap to fault-tolerance: simply improve physical error rates and then scale up via a register-based code. While this idea is simple in principle, the practical reality is quite different. Indeed, most register-based QEC codes have daunting hardware requirements, with estimates based on current experimental error levels needing millions of physical qubits (along with the associated readout and control circuitry) to run relevant quantum algorithms \cite{gidney2021factor}. 

To ease the hardware requirements, bosonic error correction has recently been developed as a hardware-efficient path forward \cite{terhal2020bosonic, cai2021bosonic, joshi2021bosonic}. Here, the building blocks of a quantum code are not individual physical qubits, but instead dynamically-protected logical \textit{bosonic} qubits, with error rates far below the QEC threshold. These bosonic qubits store quantum information in the phase space of a quantum harmonic oscillator and encode the logical codewords using complex superpositions of oscillator photon-number states. Harmonic oscillators---realized in superconducting circuits via high quality-factor cavity resonators in 3D or coplanar waveguide resonators in 2D---have a particularly simple set of error channels (predominantly just single-photon loss) as compared to other superconducting qubits. This makes bosonic QEC very attractive for building up error-corrected systems. One important consideration in practice, however, is that bosonic codes need an auxiliary nonlinear element coupled to the harmonic oscillator in order to achieve universal control and actually prepare the bosonic codewords; we will see why this is necessary in Chapter \ref{ch:2_QEC}. In superconducting circuits, this has typically been achieved by coupling a resonator to a  superconducting control qubit. This general framework of using coupled qubits and oscillators is known as circuit quantum electrodynamics (or circuit QED for short). 

As with register-based codes, there exist various families of bosonic codes, with different properties and error correction capabilities \cite{joshi2021bosonic}. One of the most notable such codes is the so-called Gottesman-Kitaev-Preskill (GKP) code whose codewords form a grid in phase space. The GKP code has been shown to be the most resilient to single-photon loss errors among the various bosonic codes \cite{albert2018performance-and-structure, noh2018performance-and-structure-pt2}, and is thus a leading candidate for building up fault-tolerant bosonic quantum processors. Unfortunately, GKP codes are highly sensitive to bit-flip (i.e. $T_1$) errors in the auxiliary control qubit, which can propagate to the oscillator and corrupt the stored quantum information in an uncorrectable way. While control qubit bit-flips are broadly a problem for most bosonic codes (for reasons we will see later), they are particularly harmful for GKP error correction. 

Previous demonstrations of bosonic codes with superconducting circuits have mostly used a transmon \cite{koch2007charge} for the auxiliary control qubit \cite{ofek2016extending, hu2019quantum, gertler2021protecting, campagne2020gkp-expt, sivak2023gkp-expt, nordquantique2023gkp-expt}. While transmons are a leading candidate for building qubit-based quantum processors \cite{krantz2019quantum, kjaergaard2020superconducting}, they have typical lifetimes of $T_1 \sim 100$ $\mu$s. In Refs. \cite{campagne2020gkp-expt, sivak2023gkp-expt, nordquantique2023gkp-expt} that implemented GKP error correction in particular, $T_1$ errors of the transmon were found to be a significant source of loss that ultimately limited the QEC performance. From this, it is evident that using a better control qubit that is less prone to bit-flips could significantly improve the performance of bosonic codes in practice. 

In this thesis, we work towards investigating this question and propose a novel platform for GKP error correction in superconducting circuits that uses a heavy fluxonium control qubit instead. Fluxonium is another leading superconducting qubit candidate and in the so-called heavy regime has been shown to achieve $T_1$ lifetimes in excess of 1 ms \cite{earnest2018realization, lin2018demonstration, zhang2021universal, ding2023FTF}. Furthermore, as a flux-tunable qubit, fluxonium opens the door to using flux control techniques in bosonic QEC experiments, and offers additional benefits such as the ability to perform fast qubit reset via sideband driving \cite{najera2024high, nie2024parametrically}. Through the course of this thesis, we will present experimental progress towards integrating a fluxonium into a 3D cavity architecture with the goal of bosonic QEC, and will also present novel proposals for future experiments that can be implemented using a fully 2D platform. 

\section{Thesis Overview}
This thesis is organized as follows. In Chapter \ref{ch:2_QEC}, we will review bosonic codes and basic notions of quantum error correction, specifically focusing on the theoretical details behind implementing QEC with the GKP grid code. In Chapter \ref{ch:3_cQED}, we will then give a short summary of superconducting qubits and circuit quantum electrodynamics (cQED). Next, Chapter \ref{ch:4_3DGKP} will go into the details of our initial 3D-GKP project in which we coupled a fluxonium qubit to a 3D cavity. We will present the theory, design, and experimental details of this project, as well as the many challenges we faced. In Chapter \ref{ch:5_2DGKP}, we will briefly discuss our upcoming plans to move our QEC experiments to a fully 2D architecture; here we will present two novel proposals to engineer faster GKP error correction using a microwave-driven coupler, as well as a new 2D re-implementation of our initial 3D experiment. Finally, we will conclude in Chapter \ref{ch:6_Conclusion} with a brief summary and outlook.


\section{Background and Suggested Reading}

This thesis aims to present a thorough review of the relevant background, but cannot cover all of the foundational knowledge required. Instead, we assume a level of familiarity with certain basic concepts. In particular, we assume that the reader is comfortable with quantum mechanics at the level of an undergraduate or graduate course, including concepts such as Hilbert space, the Schr\"odinger and Heisenberg equations, and unitary and hermitian operators; I recommend \textit{Quantum Mechanics} by R. Shankar as a good reference here \cite{shankar1994principles}. I will also assume knowledge of density matrices, the Lindblad equation, and Kraus maps, for which I highly recommend the excellent recent textbook \textit{Quantum Information Science} by Manenti and Motta \cite{manenti2023quantum}. 

Furthermore, I will assume that the readers of this thesis, being interested in quantum information science, have seen basic concepts in quantum computing before. Specifically, I will assume a reader is familiar with qubits, with basis states $\ket{0} = [1, 0]^T$ and $\ket{1} = [0, 1]^T$ represented as two dimensional vectors in a complex Hilbert space. Also the qubit Pauli operators
\begin{equation}
    \sigmax = \begin{pmatrix}
        0 & 1 \\ 1 & 0
    \end{pmatrix}, \quad \sigmay = \begin{pmatrix}
        0 & -i \\ i & 0
    \end{pmatrix}, \quad \sigmaz = \begin{pmatrix}
        1 & 0 \\ 0 & -1
    \end{pmatrix}
\end{equation}
and their commutation relations, as well as the raising/lowering operators $\sigmam = \sigmax + i\sigmay$ and $\sigmap = \sigmax - i\sigmay$. We will often refer to the qubit basis states as $\ket{g}$ and $\ket{e}$ reflecting the ground and excited energy states of a system, and will assume familiarity with the notion of a \textit{Hamiltonian} operator as the primary way to describe a quantum system. For a review of these concepts, I again highly recommend \textit{Quantum Information Science} by Manenti and Motta; it covers essentially all of the required knowledge to work as a quantum engineer. Additionally, two excellent references are \textit{Quantum Computation and Quantum Information} by Nielsen and Chuang \cite{ike-and-mike} and \textit{Quantum Processes Systems, and Information} by Schumacher and Westmoreland \cite{schumacher2010quantum}. 

\printbibliography[heading=subbibliography, title = References]
