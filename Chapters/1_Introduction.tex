\chapter{Introduction\label{ch:1_Introduction}}

\section{From Quantum Computation to Error Correction}

The field of quantum information science (QIS) involves leveraging the fundamental principles of quantum mechanics to accomplish novel and useful information processing tasks. Central to this vision is a machine called the quantum computer, which at its lowest level encodes information in the quantum mechanical degrees of freedom of a physical system. The promise of quantum computers is to solve certain computational problems more efficiently than conventional classical computers, and this has, in large part, motivated the remarkable pace of development of QIS over the last two decades. 

The low-level building blocks of quantum computers are called quantum bits, or \textit{qubits}. A physical qubit can be realized using any two-level quantum system, and there are many proposed platforms for doing so: e.g. the spin of an electron \cite{burkard2023semiconductor}, or the lowest quantized energy levels of an atom \cite{briegel2000quantum} or superconducting circuit \cite{devoret2013superconducting, krantz2019quantum, kjaergaard2020superconducting}. The latter has emerged as a leading candidate for engineering quantum systems: superconducting qubits routinely achieve coherence times on the order of hundreds of microseconds \cite{kjaergaard2020superconducting} (thanks to dedicated improvements in materials, fabrication, and circuit design), and can now be scaled up to small-to-medium-sized quantum processors. Although many of the ideas presented in this thesis are general (e.g. notions of quantum error correction), we will focus on their specific implementation within superconducting circuits. 

The basis states of a qubit are typically labelled $\ket{0}$ and $\ket{1}$, analogous to a classical bit. In quantum computation, it is also possible to have arbitrary \textit{superposition} states, specified via a linear combination
\begin{equation}
    \ket{\psi} = \alpha\ket{0} + \beta\ket{1}.
\end{equation}
Here, the values of the coefficients $|\alpha|^2$ and $|\beta|^2$ give the probabilities of measuring the quantum system in state $\ket{0}$ or $\ket{1}$. More generally, an $N$-qubit system will have $2^N$ basis states, with the most general multi-qubit state written as a superposition of all of them. A quantum computation, then, involves manipulating the quantum state of a system using a series of gate operations in order to prepare a given final state that encodes the solution. It is believed that quantum computers will offer an exponential run-time advantage over classical computers for certain difficult computational problems such as \todo{reword this paragraph, add details, and finalize a few examples (also cite relevant papers)}

Unfortunately, quantum information is---more so than classical information---highly susceptible to noise and errors due to unwanted interactions between a qubit and its environment. The simplest example of this is a \textit{bit-flip} error $\ket{1} \leftrightarrow \ket{0}$, which occurs on a characteristic timescale $T_1$ due to excitation or relaxation processes in the physical qubit. More complicated errors can also arise due to the nature of quantum superposition, e.g. \textit{phase flips}: $\ket{0} + \ket{1} \leftrightarrow \ket{0} - \ket{1}$, which occur with characteristic timescale $T_\varphi$. The process by which qubit state errors of this kind arise is known as \textit{decoherence}, and it is among the most significant challenges towards scaling up quantum systems. It has long been known that in order to achieve fault-tolerance, future quantum machines will need to actively detect when errors occur and correct them in real time via a process called quantum error correction (QEC). 

The central goal of QEC is to use a larger state space than just the two levels of a physical qubit to redundantly encode information in a manner that is robust to noise --- in a similar spirit to classical error correcting codes.
The remarkable feature of QEC is that performing quantum measurements and collapsing the physical state of the system in order to check for errors need not affect the logical information being stored. Typically, one uses a register of $N$ qubits, and stores information within a two-dimensional subspace of the $2^N$-dimensional multi-qubit state space \cite{shor1995scheme, steane1996error, gottesman1996class, kitaev2003fault, fowler2012surface}, with the most popular QEC code today being the so-called \textit{surface code} (which lays out the physical qubits on a 2D lattice and uses low-weight parity checks to detect and correct errors) \cite{fowler2012surface}. This approach is currently the ``north-star'' that our field is working towards, with many recent demonstrations showing promising QEC results using register-based codes \cite{google2023suppressing, bluvstein2024logical}. \todo{talk about QEC threshold theorem and wanting $p_{\rm err} \ll p_{\rm thres}$}

Unfortunately, most register-based quantum error correcting codes also have daunting hardware requirements, with current estimates requiring millions of physical qubits (along with the associated readout and control circuitry) to run relevant quantum algorithms \cite{gidney2021factor}. 

To ease the hardware requirements, bosonic error correction has recently been developed as a hardware-efficient path forward \cite{terhal2020bosonic, cai2021bosonic, joshi2021bosonic}. Here, the building blocks of a quantum code are not individual physical qubits, but instead themselves dynamically-protected logical qubits with error rates far below the QEC threshold. These logical qubits store information in the phase space of a quantum harmonic oscillator, using nontrivial superpositions of photon-number states in the oscillator to encode the logical codewords. Since harmonic oscillators---realized in superconducting circuits using high-Q 3D cavity resonators or 2D coplanar waveguide resonators---have a particularly simple set of loss channels compared to superconducting qubits (predominantly single-photon loss), this makes bosonic QEC particularly attractive for building up error-corrected systems. 

\todo{Introduce GKP and why we care}


\section{Structure of this thesis}
This thesis is organized as follows. In Chapter \ref{ch:2_QEC}, we will review bosonic codes and basic notions of quantum error correction, specifically focusing on the theoretical details behind implementing QEC with the GKP grid code. Here, we will also showcase some of our own numerical simulation results demonstrating the performance of GKP error correction in the presence of different loss mechanisms. In Chapter \ref{ch:3_cQED}, we will then give a brief summary of superconducting qubits and circuit quantum electrodynamics (cQED), with emphasis given to the fluxonium qubit. Next, Chapter \ref{ch:4_3DGKP} will go into the details of our initial 3D-GKP project in which we coupled a fluxonium qubit to a 3D cavity. We will present the theory, design, and experimental details of this project, as well as the many challenges we faced. In Chapter \ref{ch:5_2DGKP}, we will briefly discuss our upcoming plans to move our QEC experiments to a fully 2D architecture; here we will present two novel proposals to engineer faster GKP error correction using a microwave-driven coupler, as well as a new 2D re-implementation of our initial 3D experiment. Finally, we will conclude in Chapter \ref{ch:6_Conclusion} with a short summary and outlook.



% E.g. from Max: This thesis is arranged into two parts: a main body where we present the ideas and results central to this thesis (chapters 2-5), and a series of later chapters that give detailed explanations and information concerning those same ideas and results. 

% In the main chapters, we will first give an overview of how Andreev levels arise in weak links, with a focus on how the Andreev levels of Josephson nanowires differ from those of conventional tunnel junctions. 
% We will then discuss how Andreev levels can be probed using cQED, and present as a case study our investigation of pair transitions in Josephson nanowires. 
% Finally, we will present the main result of thesis: the realization of the Andreev spin qubit, which is formed from the two spin states of a quasiparticle trapped in the Andreev levels of a Josephson nanowire.  

% ============= OLD ======================
% It is sometimes said that the idea that quantum error correction is possible at all is even more remarkable that the concept of quantum computation itself. By redundantly encoding information into a larger state space than the two levels of a physical qubit, we can store both the logical quantum state as well as information about the errors. The incredible feature of QEC is that collapsing the physical state of the system to infer whether or not an error has occurred need not affect the logical state being stored. Since the first QEC code introduced by Peter Shor in the mid-nineties \cite{shor1995scheme}, there have been a variety of quantum codes that have been proposed and studied \cite{steane1996error, gottesman1996class, kitaev2003fault, fowler2012surface}. The most popular of these is the surface code \cite{fowler2012surface}, which uses a register of physical `data' qubits arranged in a 2D lattice. Using $N$ physical qubits, the size of the redundant state space grows as $\mathcal{O}(2^N)$. Furthermore, the surface code has the useful property that if the physical error rate per qubit $p_{\rm err}$ is below a threshold value $p_{\rm thres}$, the total logical error rate $p_L$ decreases \textit{exponentially} with increasing $N$. As a concept, this is very attractive and is the reason why the surface code is the current ``north star'' in our field that  various experimental quantum computing groups across academia and industry are working towards. 

% In practice, however, the  experimental challenges associated with building register-based QEC codes are quite considerable. The first is the exponentially growing hardware complexity required to manipulate such a large register of qubits. In superconducting qubits, for instance, each physical qubit may require its own readout resonator, several drive and/or flux lines, a number of tunable couplers, and more. This issue is exacerbated by the fact that, at current physical error rates $p_{\rm err}$, full error correction is expected to require millions of physical qubits. Another big issue is that hardware error rates can only be improved so much by advances in materials and fabrication. Therefore, reaching and far surpassing the error correction threshold (sometimes estimated to be roughly $p_{\rm thres} \simeq 1\%$) is challenging. What if there was a better way? What if the building block of a future register-based code is not a physical two-level system, but itself a protected mini-logical qubit? 

% Bosonic codes encode quantum information the phase space of a quantum harmonic oscillator, and have recently been demonstrated to provide a hardware-efficient alternative towards building up error corrected 

% but this is very challenging to hit $p_{err} = p_{thres}$. Ideally, we want error prob $\ll$ thres. Furthermore, the hardware and software requirements also grow exponentially for larger register based codes. What if the building blocks of a future surface code was a protected mini logical qubit, with $p_{\rm err} \ll $ threshold? Then, only a small register of such qubits would be required to build up a surface code, making the implementation much more hardware efficient overall. A great way to do this is a bosonic code. 

% Bosonic codes encode information in the phase space of a quantum harmonic oscillator. Many have been proposed, such as GKP, binomial, cat codes --- various interesting superpositions of photon number states in the resonator. To realize bosonic codes, we still need a nonlinear element (i.e. a qubit) in order to achieve universal control over a resonator and prepare the states. And this is where our current research begins. 

%We work in the field of superconducting qubits. In SCQ, most previous implementations of bosonic codes use high-Q 3D cavity resonators for the bosonic mode, and transmon qubits as the control element. Unfortunately, transmon qubits